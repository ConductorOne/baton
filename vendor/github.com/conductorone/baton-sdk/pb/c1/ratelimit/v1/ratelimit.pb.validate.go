// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: c1/ratelimit/v1/ratelimit.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RateLimitDescription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RateLimitDescription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimitDescription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimitDescriptionMultiError, or nil if none found.
func (m *RateLimitDescription) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimitDescription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Limit

	// no validation rules for Remaining

	// no validation rules for Count

	if all {
		switch v := interface{}(m.GetResetAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimitDescriptionValidationError{
					field:  "ResetAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimitDescriptionValidationError{
					field:  "ResetAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResetAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimitDescriptionValidationError{
				field:  "ResetAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RateLimitDescriptionMultiError(errors)
	}

	return nil
}

// RateLimitDescriptionMultiError is an error wrapping multiple validation
// errors returned by RateLimitDescription.ValidateAll() if the designated
// constraints aren't met.
type RateLimitDescriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimitDescriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimitDescriptionMultiError) AllErrors() []error { return m }

// RateLimitDescriptionValidationError is the validation error returned by
// RateLimitDescription.Validate if the designated constraints aren't met.
type RateLimitDescriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimitDescriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimitDescriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimitDescriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimitDescriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimitDescriptionValidationError) ErrorName() string {
	return "RateLimitDescriptionValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimitDescriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimitDescription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimitDescriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimitDescriptionValidationError{}

// Validate checks the field values on ReportRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportRequestMultiError, or
// nil if none found.
func (m *ReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestToken

	if all {
		switch v := interface{}(m.GetDescription()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportRequestValidationError{
					field:  "Description",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportRequestValidationError{
					field:  "Description",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDescription()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportRequestValidationError{
				field:  "Description",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Service

	if all {
		switch v := interface{}(m.GetDescriptors()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportRequestValidationError{
					field:  "Descriptors",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportRequestValidationError{
					field:  "Descriptors",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDescriptors()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportRequestValidationError{
				field:  "Descriptors",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportRequestMultiError(errors)
	}

	return nil
}

// ReportRequestMultiError is an error wrapping multiple validation errors
// returned by ReportRequest.ValidateAll() if the designated constraints
// aren't met.
type ReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportRequestMultiError) AllErrors() []error { return m }

// ReportRequestValidationError is the validation error returned by
// ReportRequest.Validate if the designated constraints aren't met.
type ReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportRequestValidationError) ErrorName() string { return "ReportRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportRequestValidationError{}

// Validate checks the field values on ReportResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportResponseMultiError,
// or nil if none found.
func (m *ReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReportResponseMultiError(errors)
	}

	return nil
}

// ReportResponseMultiError is an error wrapping multiple validation errors
// returned by ReportResponse.ValidateAll() if the designated constraints
// aren't met.
type ReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportResponseMultiError) AllErrors() []error { return m }

// ReportResponseValidationError is the validation error returned by
// ReportResponse.Validate if the designated constraints aren't met.
type ReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportResponseValidationError) ErrorName() string { return "ReportResponseValidationError" }

// Error satisfies the builtin error interface
func (e ReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportResponseValidationError{}

// Validate checks the field values on RateLimitDescriptors with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RateLimitDescriptors) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimitDescriptors with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimitDescriptorsMultiError, or nil if none found.
func (m *RateLimitDescriptors) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimitDescriptors) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetEntries()) < 1 {
		err := RateLimitDescriptorsValidationError{
			field:  "Entries",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RateLimitDescriptorsValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RateLimitDescriptorsValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RateLimitDescriptorsValidationError{
					field:  fmt.Sprintf("Entries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RateLimitDescriptorsMultiError(errors)
	}

	return nil
}

// RateLimitDescriptorsMultiError is an error wrapping multiple validation
// errors returned by RateLimitDescriptors.ValidateAll() if the designated
// constraints aren't met.
type RateLimitDescriptorsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimitDescriptorsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimitDescriptorsMultiError) AllErrors() []error { return m }

// RateLimitDescriptorsValidationError is the validation error returned by
// RateLimitDescriptors.Validate if the designated constraints aren't met.
type RateLimitDescriptorsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimitDescriptorsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimitDescriptorsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimitDescriptorsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimitDescriptorsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimitDescriptorsValidationError) ErrorName() string {
	return "RateLimitDescriptorsValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimitDescriptorsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimitDescriptors.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimitDescriptorsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimitDescriptorsValidationError{}

// Validate checks the field values on DoRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DoRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DoRequestMultiError, or nil
// if none found.
func (m *DoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestToken

	// no validation rules for Service

	if all {
		switch v := interface{}(m.GetDescriptors()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DoRequestValidationError{
					field:  "Descriptors",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DoRequestValidationError{
					field:  "Descriptors",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDescriptors()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DoRequestValidationError{
				field:  "Descriptors",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DoRequestMultiError(errors)
	}

	return nil
}

// DoRequestMultiError is an error wrapping multiple validation errors returned
// by DoRequest.ValidateAll() if the designated constraints aren't met.
type DoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DoRequestMultiError) AllErrors() []error { return m }

// DoRequestValidationError is the validation error returned by
// DoRequest.Validate if the designated constraints aren't met.
type DoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DoRequestValidationError) ErrorName() string { return "DoRequestValidationError" }

// Error satisfies the builtin error interface
func (e DoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DoRequestValidationError{}

// Validate checks the field values on DoResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DoResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DoResponseMultiError, or
// nil if none found.
func (m *DoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestToken

	if all {
		switch v := interface{}(m.GetDescription()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DoResponseValidationError{
					field:  "Description",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DoResponseValidationError{
					field:  "Description",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDescription()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DoResponseValidationError{
				field:  "Description",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DoResponseMultiError(errors)
	}

	return nil
}

// DoResponseMultiError is an error wrapping multiple validation errors
// returned by DoResponse.ValidateAll() if the designated constraints aren't met.
type DoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DoResponseMultiError) AllErrors() []error { return m }

// DoResponseValidationError is the validation error returned by
// DoResponse.Validate if the designated constraints aren't met.
type DoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DoResponseValidationError) ErrorName() string { return "DoResponseValidationError" }

// Error satisfies the builtin error interface
func (e DoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DoResponseValidationError{}

// Validate checks the field values on DisabledLimiter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DisabledLimiter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisabledLimiter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DisabledLimiterMultiError, or nil if none found.
func (m *DisabledLimiter) ValidateAll() error {
	return m.validate(true)
}

func (m *DisabledLimiter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DisabledLimiterMultiError(errors)
	}

	return nil
}

// DisabledLimiterMultiError is an error wrapping multiple validation errors
// returned by DisabledLimiter.ValidateAll() if the designated constraints
// aren't met.
type DisabledLimiterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisabledLimiterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisabledLimiterMultiError) AllErrors() []error { return m }

// DisabledLimiterValidationError is the validation error returned by
// DisabledLimiter.Validate if the designated constraints aren't met.
type DisabledLimiterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisabledLimiterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisabledLimiterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisabledLimiterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisabledLimiterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisabledLimiterValidationError) ErrorName() string { return "DisabledLimiterValidationError" }

// Error satisfies the builtin error interface
func (e DisabledLimiterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisabledLimiter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisabledLimiterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisabledLimiterValidationError{}

// Validate checks the field values on SlidingMemoryLimiter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SlidingMemoryLimiter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SlidingMemoryLimiter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SlidingMemoryLimiterMultiError, or nil if none found.
func (m *SlidingMemoryLimiter) ValidateAll() error {
	return m.validate(true)
}

func (m *SlidingMemoryLimiter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UsePercent

	if len(errors) > 0 {
		return SlidingMemoryLimiterMultiError(errors)
	}

	return nil
}

// SlidingMemoryLimiterMultiError is an error wrapping multiple validation
// errors returned by SlidingMemoryLimiter.ValidateAll() if the designated
// constraints aren't met.
type SlidingMemoryLimiterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SlidingMemoryLimiterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SlidingMemoryLimiterMultiError) AllErrors() []error { return m }

// SlidingMemoryLimiterValidationError is the validation error returned by
// SlidingMemoryLimiter.Validate if the designated constraints aren't met.
type SlidingMemoryLimiterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SlidingMemoryLimiterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SlidingMemoryLimiterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SlidingMemoryLimiterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SlidingMemoryLimiterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SlidingMemoryLimiterValidationError) ErrorName() string {
	return "SlidingMemoryLimiterValidationError"
}

// Error satisfies the builtin error interface
func (e SlidingMemoryLimiterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSlidingMemoryLimiter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SlidingMemoryLimiterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SlidingMemoryLimiterValidationError{}

// Validate checks the field values on FixedMemoryLimiter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FixedMemoryLimiter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FixedMemoryLimiter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FixedMemoryLimiterMultiError, or nil if none found.
func (m *FixedMemoryLimiter) ValidateAll() error {
	return m.validate(true)
}

func (m *FixedMemoryLimiter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rate

	if all {
		switch v := interface{}(m.GetPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FixedMemoryLimiterValidationError{
					field:  "Period",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FixedMemoryLimiterValidationError{
					field:  "Period",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FixedMemoryLimiterValidationError{
				field:  "Period",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FixedMemoryLimiterMultiError(errors)
	}

	return nil
}

// FixedMemoryLimiterMultiError is an error wrapping multiple validation errors
// returned by FixedMemoryLimiter.ValidateAll() if the designated constraints
// aren't met.
type FixedMemoryLimiterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FixedMemoryLimiterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FixedMemoryLimiterMultiError) AllErrors() []error { return m }

// FixedMemoryLimiterValidationError is the validation error returned by
// FixedMemoryLimiter.Validate if the designated constraints aren't met.
type FixedMemoryLimiterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FixedMemoryLimiterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FixedMemoryLimiterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FixedMemoryLimiterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FixedMemoryLimiterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FixedMemoryLimiterValidationError) ErrorName() string {
	return "FixedMemoryLimiterValidationError"
}

// Error satisfies the builtin error interface
func (e FixedMemoryLimiterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFixedMemoryLimiter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FixedMemoryLimiterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FixedMemoryLimiterValidationError{}

// Validate checks the field values on ExternalLimiter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExternalLimiter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExternalLimiter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExternalLimiterMultiError, or nil if none found.
func (m *ExternalLimiter) ValidateAll() error {
	return m.validate(true)
}

func (m *ExternalLimiter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Options

	if len(errors) > 0 {
		return ExternalLimiterMultiError(errors)
	}

	return nil
}

// ExternalLimiterMultiError is an error wrapping multiple validation errors
// returned by ExternalLimiter.ValidateAll() if the designated constraints
// aren't met.
type ExternalLimiterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExternalLimiterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExternalLimiterMultiError) AllErrors() []error { return m }

// ExternalLimiterValidationError is the validation error returned by
// ExternalLimiter.Validate if the designated constraints aren't met.
type ExternalLimiterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExternalLimiterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExternalLimiterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExternalLimiterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExternalLimiterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExternalLimiterValidationError) ErrorName() string { return "ExternalLimiterValidationError" }

// Error satisfies the builtin error interface
func (e ExternalLimiterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExternalLimiter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExternalLimiterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExternalLimiterValidationError{}

// Validate checks the field values on RateLimiterConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RateLimiterConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimiterConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimiterConfigMultiError, or nil if none found.
func (m *RateLimiterConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimiterConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *RateLimiterConfig_Disabled:
		if v == nil {
			err := RateLimiterConfigValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDisabled()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RateLimiterConfigValidationError{
						field:  "Disabled",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RateLimiterConfigValidationError{
						field:  "Disabled",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDisabled()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RateLimiterConfigValidationError{
					field:  "Disabled",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RateLimiterConfig_SlidingMem:
		if v == nil {
			err := RateLimiterConfigValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSlidingMem()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RateLimiterConfigValidationError{
						field:  "SlidingMem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RateLimiterConfigValidationError{
						field:  "SlidingMem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSlidingMem()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RateLimiterConfigValidationError{
					field:  "SlidingMem",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RateLimiterConfig_FixedMem:
		if v == nil {
			err := RateLimiterConfigValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFixedMem()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RateLimiterConfigValidationError{
						field:  "FixedMem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RateLimiterConfigValidationError{
						field:  "FixedMem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFixedMem()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RateLimiterConfigValidationError{
					field:  "FixedMem",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RateLimiterConfig_External:
		if v == nil {
			err := RateLimiterConfigValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExternal()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RateLimiterConfigValidationError{
						field:  "External",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RateLimiterConfigValidationError{
						field:  "External",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExternal()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RateLimiterConfigValidationError{
					field:  "External",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RateLimiterConfigMultiError(errors)
	}

	return nil
}

// RateLimiterConfigMultiError is an error wrapping multiple validation errors
// returned by RateLimiterConfig.ValidateAll() if the designated constraints
// aren't met.
type RateLimiterConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimiterConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimiterConfigMultiError) AllErrors() []error { return m }

// RateLimiterConfigValidationError is the validation error returned by
// RateLimiterConfig.Validate if the designated constraints aren't met.
type RateLimiterConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimiterConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimiterConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimiterConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimiterConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimiterConfigValidationError) ErrorName() string {
	return "RateLimiterConfigValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimiterConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimiterConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimiterConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimiterConfigValidationError{}

// Validate checks the field values on RateLimitDescriptors_Entry with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RateLimitDescriptors_Entry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimitDescriptors_Entry with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimitDescriptors_EntryMultiError, or nil if none found.
func (m *RateLimitDescriptors_Entry) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimitDescriptors_Entry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKey()) < 1 {
		err := RateLimitDescriptors_EntryValidationError{
			field:  "Key",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetValue()) < 1 {
		err := RateLimitDescriptors_EntryValidationError{
			field:  "Value",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RateLimitDescriptors_EntryMultiError(errors)
	}

	return nil
}

// RateLimitDescriptors_EntryMultiError is an error wrapping multiple
// validation errors returned by RateLimitDescriptors_Entry.ValidateAll() if
// the designated constraints aren't met.
type RateLimitDescriptors_EntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimitDescriptors_EntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimitDescriptors_EntryMultiError) AllErrors() []error { return m }

// RateLimitDescriptors_EntryValidationError is the validation error returned
// by RateLimitDescriptors_Entry.Validate if the designated constraints aren't met.
type RateLimitDescriptors_EntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimitDescriptors_EntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimitDescriptors_EntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimitDescriptors_EntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimitDescriptors_EntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimitDescriptors_EntryValidationError) ErrorName() string {
	return "RateLimitDescriptors_EntryValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimitDescriptors_EntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimitDescriptors_Entry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimitDescriptors_EntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimitDescriptors_EntryValidationError{}
